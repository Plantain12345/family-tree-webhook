<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Family Tree</title>
  <style>
    :root {
      --bg: #ffffff;
      --surface: #ffffff;
      --panel: #fbf7f2;
      --ink: #2f2217;
      --muted: #6f6255;
      --border: #e8ded2;
      --accent: #d87b5d;
      --status-bg: rgba(216, 123, 93, 0.12);
    }

    html,
    body {
      margin: 0;
      min-height: 100%;
      font-family: "Inter", "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--ink);
      background: var(--bg);
    }

    body {
      display: flex;
      flex-direction: column;
    }

    .shell {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 24px;
      padding: 28px 36px 20px;
      background: var(--surface);
      box-shadow: 0 12px 32px rgba(21, 12, 4, 0.05);
      z-index: 10;
    }

    .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .title-prefix {
      text-transform: uppercase;
      letter-spacing: 0.18em;
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
    }

    h1 {
      margin: 0;
      font-size: 26px;
      font-weight: 600;
    }

    #status {
      font-size: 12px;
      font-weight: 500;
      color: var(--accent);
      background: var(--status-bg);
      padding: 8px 14px;
      border-radius: 999px;
      align-self: flex-start;
      white-space: nowrap;
    }

    main {
      flex: 1;
      position: relative;
      padding: 24px 36px 36px;
      background: linear-gradient(180deg, rgba(248, 242, 236, 0.55) 0%, rgba(255, 255, 255, 0.9) 60%, rgba(255, 255, 255, 1) 100%);
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .legend {
      position: absolute;
      top: 42px;
      right: 56px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--muted);
    }

    .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      display: inline-block;
      border: 1px solid rgba(0, 0, 0, 0.05);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.8);
    }

    .legend-swatch.male {
      background: #c8daf9;
    }

    .legend-swatch.female {
      background: #f8d5e4;
    }

    .legend-swatch.neutral {
      background: #e3dbf7;
    }

    .legend-swatch.unknown {
      background: #f4efe7;
    }

    .alerts {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-self: flex-start;
      background: rgba(255, 255, 255, 0.75);
      border-radius: 16px;
      border: 1px solid var(--border);
      padding: 16px 20px;
      box-shadow: 0 24px 46px rgba(27, 17, 8, 0.08);
    }

    .alerts strong {
      font-size: 13px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--accent);
    }

    .alerts ul {
      margin: 0;
      padding-left: 18px;
      font-size: 13px;
      color: var(--muted);
    }

    #cy {
      width: 100%;
      flex: 1;
      min-height: 480px;
      border-radius: 26px;
      background: var(--panel);
      border: 1px solid var(--border);
      box-shadow: 0 28px 60px rgba(27, 17, 8, 0.08);
    }

    #empty {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    #empty .box {
      text-align: center;
      color: var(--muted);
      padding: 32px 40px;
      border-radius: 20px;
      background: rgba(255, 255, 255, 0.8);
      box-shadow: 0 18px 44px rgba(17, 10, 4, 0.08);
      border: 1px solid var(--border);
      pointer-events: auto;
    }

    #empty .box strong {
      display: block;
      font-size: 18px;
      margin-bottom: 6px;
      color: var(--ink);
    }

    #empty .share-actions {
      margin-top: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
    }

    #empty .share-note {
      font-size: 14px;
      color: var(--muted);
      max-width: 320px;
      line-height: 1.5;
    }

    #share-tree-button {
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 999px;
      padding: 12px 24px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, opacity 0.15s ease;
    }

    #share-tree-button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      box-shadow: none;
    }

    #share-tree-button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 28px rgba(216, 123, 93, 0.35);
    }

    @media (max-width: 720px) {
      header {
        flex-direction: column;
        align-items: flex-start;
        gap: 18px;
      }

      .legend {
        position: static;
        margin-bottom: 16px;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 14px;
        justify-content: center;
      }

      .alerts {
        margin-top: 12px;
        align-self: stretch;
      }

      #empty {
        inset: 24px;
      }
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="title-block">
        <span class="title-prefix">Family Tree:</span>
        <h1 id="tree-name">Loading…</h1>
      </div>
      <div id="status">Loading…</div>
    </header>

    <main>
      <div class="legend">
        <span class="legend-item"><span class="legend-swatch male"></span>Male</span>
        <span class="legend-item"><span class="legend-swatch female"></span>Female</span>
        <span class="legend-item"><span class="legend-swatch neutral"></span>Non-binary</span>
        <span class="legend-item"><span class="legend-swatch unknown"></span>Not specified</span>
      </div>
      <div id="alerts" class="alerts" hidden></div>
      <div id="cy"></div>
      <div id="empty"><div class="box">
        <strong>Invite your family</strong>
        <div class="share-actions">
          <button id="share-tree-button" type="button" disabled>Share This Tree.</button>
          <span class="share-note">You can collaborate with others to grow this tree.</span>
        </div>
      </div></div>
    </main>
  </div>

  <script src="https://unpkg.com/cytoscape@3.27.0/dist/cytoscape.min.js"></script>
  <script>
    const qs = new URLSearchParams(location.search);
    const code = (qs.get("code") || "").toUpperCase();
    const treeNameEl = document.getElementById("tree-name");
    const statusEl = document.getElementById("status");
    const emptyEl = document.getElementById("empty");
    const alertsEl = document.getElementById("alerts");
    const shareButton = document.getElementById("share-tree-button");
    const REFRESH_INTERVAL_MS = 60000;

    let shareMessage = null;

    if (!/^[A-Z0-9]{6}$/.test(code)) {
      document.body.innerHTML = "<p style='padding:16px'>Missing or bad code. Use ?code=ABC123</p>";
      throw new Error("bad code");
    }

    if (shareButton) {
      shareButton.addEventListener("click", () => {
        if (!shareMessage) return;
        const encoded = encodeURIComponent(shareMessage);
        const targetUrl = `https://wa.me/?text=${encoded}`;
        const popup = window.open(targetUrl, "_blank", "noopener,noreferrer");
        if (popup) popup.opener = null;
      });
    }

    const cy = cytoscape({
      container: document.getElementById("cy"),
      elements: [],
      style: [
        {
          selector: "node.person",
          style: {
            "background-color": "#f1e6da",
            "border-color": "#bda58f",
            "border-width": 2,
            width: 108,
            height: 108,
            padding: "12px",
            shape: "ellipse",
            label: "data(label)",
            "text-wrap": "wrap",
            "text-max-width": 96,
            "font-size": 14,
            "text-valign": "center",
            "text-halign": "center",
            color: "#2f2217",
            "font-weight": 500,
            "overlay-opacity": 0
          }
        },
        {
          selector: "node.gender-male",
          style: {
            shape: "square",
            "background-color": "#7ea5f8",
            "border-color": "#4c6dc3"
          }
        },
        {
          selector: "node.gender-female",
          style: {
            shape: "ellipse",
            "background-color": "#f8b3cf",
            "border-color": "#d47ca1"
          }
        },
        {
          selector: "node.gender-nonbinary",
          style: {
            shape: "diamond",
            "background-color": "#d9c4f7",
            "border-color": "#a88ed7"
          }
        },
        {
          selector: "node.gender-unknown",
          style: {
            shape: "round-rectangle",
            "background-color": "#ece2d6",
            "border-color": "#cbb49d"
          }
        },
        {
          selector: "node.family-connector",
          style: {
            width: 2,
            height: 2,
            shape: "rectangle",
            opacity: 0
          }
        },
        {
          selector: "node.sibling-drop",
          style: {
            width: 2,
            height: 2,
            shape: "rectangle",
            opacity: 0
          }
        },
        {
          selector: "edge",
          style: {
            "curve-style": "straight",
            width: 2,
            "line-color": "#3d3126",
            "target-arrow-shape": "none",
            "source-arrow-shape": "none",
            opacity: 1
          }
        },
        {
          selector: "edge.marriage",
          style: {
            width: 3
          }
        },
        {
          selector: "edge.marriage.divorced",
          style: {
            "line-style": "dashed"
          }
        },
        {
          selector: "edge.parent-connector",
          style: {
            width: 2
          }
        },
        {
          selector: "edge.sibship-link",
          style: {
            width: 2
          }
        },
        {
          selector: "edge.child-link",
          style: {
            width: 2
          }
        },
        {
          selector: "edge.generic",
          style: {
            "line-style": "dotted",
            "line-color": "#9f8c7a"
          }
        }
      ],
      layout: { name: "preset" },
      wheelSensitivity: 0.2
    });

    window.addEventListener("resize", () => {
      cy.resize();
    });

    const HORIZONTAL_SPACING = 220;
    const VERTICAL_SPACING = 200;
    const DROP_VERTICAL_OFFSET = 70;

    function normalizeGender(value) {
      if (value === null || value === undefined) return "unknown";
      const lower = String(value).trim().toLowerCase();
      if (!lower) return "unknown";
      if (["m", "male", "man", "boy"].includes(lower)) return "male";
      if (["f", "female", "woman", "girl"].includes(lower)) return "female";
      if (["nb", "nonbinary", "non-binary", "non binary", "enby"].includes(lower)) {
        return "nonbinary";
      }
      return "unknown";
    }

    function parseDobValue(dob) {
      if (!dob) return Number.POSITIVE_INFINITY;
      const trimmed = String(dob).trim();
      if (!trimmed) return Number.POSITIVE_INFINITY;
      const parsed = Date.parse(trimmed);
      if (!Number.isNaN(parsed)) return parsed;
      const ymd = trimmed.match(/^(\d{4})[-/](\d{1,2})[-/](\d{1,2})$/);
      if (ymd) {
        const [, y, m, d] = ymd;
        return Date.parse(`${y}-${m.padStart(2, "0")}-${d.padStart(2, "0")}`);
      }
      const dmy = trimmed.match(/^(\d{1,2})[-/](\d{1,2})[-/](\d{2,4})$/);
      if (dmy) {
        const [, d, m, yRaw] = dmy;
        const year = yRaw.length === 2 ? `19${yRaw}` : yRaw.padStart(4, "0");
        return Date.parse(`${year}-${m.padStart(2, "0")}-${d.padStart(2, "0")}`);
      }
      const year = trimmed.match(/(\d{4})/);
      if (year) return Date.parse(`${year[1]}-01-01`);
      return Number.POSITIVE_INFINITY;
    }

    function compareByBirthThenName(a, b, birthValues, labelMap) {
      const aVal = birthValues.get(a) ?? Number.POSITIVE_INFINITY;
      const bVal = birthValues.get(b) ?? Number.POSITIVE_INFINITY;
      if (aVal !== bVal) return aVal - bVal;
      const aLabel = (labelMap.get(a) || "").toLowerCase();
      const bLabel = (labelMap.get(b) || "").toLowerCase();
      if (aLabel && bLabel) return aLabel.localeCompare(bLabel);
      if (aLabel) return -1;
      if (bLabel) return 1;
      return String(a).localeCompare(String(b));
    }

    function buildElements(nodeList = [], edgeList = [], families = []) {
      const personMap = new Map();
      const birthValues = new Map();
      const labelByPerson = new Map();

      for (const node of nodeList) {
        if (!node?.data?.id) continue;
        const gender = normalizeGender(node.data.gender);
        const classes = ["person", `gender-${gender || "unknown"}`].join(" ");
        const dobValue = parseDobValue(node.data.dob || null);
        birthValues.set(node.data.id, dobValue);
        labelByPerson.set(node.data.id, node.data.label || "");
        personMap.set(node.data.id, {
          id: node.data.id,
          data: { ...node.data },
          classes,
          gender
        });
      }

      const parentsByChild = new Map();
      const familiesNormalised = (families || []).map((family) => {
        const parents = Array.from(
          new Set(
            (Array.isArray(family?.spouses)
              ? family.spouses
              : Array.isArray(family?.parents)
              ? family.parents
              : []
            ).filter((id) => personMap.has(id))
          )
        );
        const children = Array.from(
          new Set(
            (Array.isArray(family?.children) ? family.children : []).filter((id) =>
              personMap.has(id)
            )
          )
        );
        for (const child of children) {
          if (!parentsByChild.has(child)) parentsByChild.set(child, new Set());
          for (const parent of parents) parentsByChild.get(child).add(parent);
        }
        return {
          id: family.id || `family_${parents.join("_") || "solo"}`,
          parents,
          children,
          status: family.status || null
        };
      });

      for (const edge of edgeList || []) {
        const kind = edge?.data?.kind;
        if (!kind) continue;
        if (kind === "parent_of") {
          const parent = edge.data.source;
          const child = edge.data.target;
          if (!personMap.has(parent) || !personMap.has(child)) continue;
          if (!parentsByChild.has(child)) parentsByChild.set(child, new Set());
          parentsByChild.get(child).add(parent);
        }
        if (kind === "child_of") {
          const parent = edge.data.target;
          const child = edge.data.source;
          if (!personMap.has(parent) || !personMap.has(child)) continue;
          if (!parentsByChild.has(child)) parentsByChild.set(child, new Set());
          parentsByChild.get(child).add(parent);
        }
      }

      const generationMap = new Map();
      const visiting = new Set();

      function computeGeneration(personId) {
        if (generationMap.has(personId)) return generationMap.get(personId);
        if (visiting.has(personId)) return 0;
        visiting.add(personId);
        const parents = parentsByChild.get(personId);
        let generation = 0;
        if (parents && parents.size) {
          let maxParentGen = 0;
          for (const parentId of parents) {
            maxParentGen = Math.max(maxParentGen, computeGeneration(parentId));
          }
          generation = maxParentGen + 1;
        }
        visiting.delete(personId);
        generationMap.set(personId, generation);
        return generation;
      }

      for (const personId of personMap.keys()) {
        computeGeneration(personId);
      }

      const positions = new Map();
      const generationCursor = new Map();

      function placeGroup(generation, ids, sort = false) {
        if (!ids || !ids.length) return;
        const filtered = ids.filter((id) => personMap.has(id));
        if (!filtered.length) return;
        const unique = [];
        const seen = new Set();
        for (const id of filtered) {
          if (seen.has(id)) continue;
          seen.add(id);
          unique.push(id);
        }
        if (!unique.length) return;
        const order = sort
          ? unique.slice().sort((a, b) =>
              compareByBirthThenName(a, b, birthValues, labelByPerson)
            )
          : unique;
        const cursorStart = generationCursor.get(generation) || 0;
        let placedCount = 0;
        for (const id of order) {
          if (positions.has(id)) continue;
          const slot = cursorStart + placedCount;
          positions.set(id, {
            x: slot * HORIZONTAL_SPACING,
            y: generation * VERTICAL_SPACING
          });
          placedCount += 1;
        }
        if (placedCount > 0) {
          generationCursor.set(generation, cursorStart + placedCount + 1);
        }
      }

      const rootCandidates = [];
      for (const personId of personMap.keys()) {
        const parents = parentsByChild.get(personId);
        if (!parents || !parents.size) rootCandidates.push(personId);
      }
      placeGroup(0, rootCandidates, true);

      const familiesSorted = familiesNormalised
        .slice()
        .sort((a, b) => {
          const aGen = Math.min(
            ...a.parents.map((id) => generationMap.get(id) ?? 0),
            generationMap.get(a.children[0] || "") ?? 0
          );
          const bGen = Math.min(
            ...b.parents.map((id) => generationMap.get(id) ?? 0),
            generationMap.get(b.children[0] || "") ?? 0
          );
          if (aGen !== bGen) return aGen - bGen;
          return (a.id || "").localeCompare(b.id || "");
        });

      for (const family of familiesSorted) {
        const parentGenerations = family.parents.map((id) => generationMap.get(id) ?? 0);
        const parentGeneration = parentGenerations.length
          ? Math.min(...parentGenerations)
          : 0;
        placeGroup(parentGeneration, family.parents, true);

        const childrenByGeneration = new Map();
        for (const childId of family.children) {
          const gen = generationMap.get(childId) ?? parentGeneration + 1;
          if (!childrenByGeneration.has(gen)) childrenByGeneration.set(gen, []);
          childrenByGeneration.get(gen).push(childId);
        }
        for (const [gen, childIds] of childrenByGeneration.entries()) {
          const ordered = family.children.filter((id) => childIds.includes(id));
          placeGroup(gen, ordered, false);
        }
      }

      for (const [personId] of personMap) {
        if (positions.has(personId)) continue;
        const gen = generationMap.get(personId) ?? 0;
        placeGroup(gen, [personId], true);
      }

      const elements = [];
      for (const person of personMap.values()) {
        const position = positions.get(person.id) || { x: 0, y: 0 };
        elements.push({
          data: { ...person.data },
          classes: person.classes,
          position
        });
      }

      const addedMarriages = new Set();
      for (const family of familiesNormalised) {
        if (family.parents.length >= 2) {
          const sortedParents = family.parents
            .slice()
            .sort((a, b) =>
              compareByBirthThenName(a, b, birthValues, labelByPerson)
            );
          for (let i = 0; i < sortedParents.length; i++) {
            for (let j = i + 1; j < sortedParents.length; j++) {
              const a = sortedParents[i];
              const b = sortedParents[j];
              const key = `${a}_${b}`;
              if (addedMarriages.has(key)) continue;
              addedMarriages.add(key);
              elements.push({
                data: {
                  id: `${family.id}_marriage_${a}_${b}`,
                  source: a,
                  target: b,
                  kind: "marriage",
                  familyId: family.id
                },
                classes: `marriage${family.status ? " divorced" : ""}`.trim()
              });
            }
          }
        }
      }

      for (const family of familiesNormalised) {
        if (!family.parents.length && !family.children.length) continue;
        const parentPositions = family.parents
          .map((id) => positions.get(id))
          .filter(Boolean);
        const childPositions = family.children
          .map((id) => positions.get(id))
          .filter(Boolean);

        if (!parentPositions.length && !childPositions.length) continue;

        const centerX =
          parentPositions.length
            ? parentPositions.reduce((sum, pos) => sum + pos.x, 0) /
              parentPositions.length
            : childPositions.length
            ? childPositions.reduce((sum, pos) => sum + pos.x, 0) /
              childPositions.length
            : 0;
        const parentY =
          parentPositions.length
            ? parentPositions.reduce((sum, pos) => sum + pos.y, 0) /
              parentPositions.length
            : childPositions.length
            ? Math.min(...childPositions.map((pos) => pos.y)) - VERTICAL_SPACING * 0.6
            : 0;
        const childY =
          childPositions.length
            ? childPositions.reduce((sum, pos) => sum + pos.y, 0) /
              childPositions.length
            : parentY + VERTICAL_SPACING;

        const connectorY = parentY + Math.max(30, Math.min((childY - parentY) * 0.4, 100));
        const connectorId = `${family.id}_connector`;

        elements.push({
          data: { id: connectorId, familyId: family.id },
          classes: "family-connector",
          position: { x: centerX, y: connectorY }
        });

        for (const parentId of family.parents) {
          elements.push({
            data: {
              id: `${family.id}_connector_${parentId}`,
              source: parentId,
              target: connectorId,
              kind: "parent_connector",
              familyId: family.id
            },
            classes: "parent-connector"
          });
        }

        if (!family.children.length) continue;

        const rawDrop = childY - DROP_VERTICAL_OFFSET;
        const dropY = Math.max(
          connectorY + 12,
          Math.min(rawDrop, childY - 30)
        );
        const dropNodes = [];
        for (const childId of family.children) {
          const childPosition = positions.get(childId);
          if (!childPosition) continue;
          const dropId = `${family.id}_drop_${childId}`;
          dropNodes.push({ id: dropId, childId, x: childPosition.x });
          elements.push({
            data: { id: dropId, familyId: family.id, childId },
            classes: "sibling-drop",
            position: { x: childPosition.x, y: dropY }
          });
          elements.push({
            data: {
              id: `${dropId}_child`,
              source: dropId,
              target: childId,
              familyId: family.id,
              kind: "child_link"
            },
            classes: "child-link"
          });
        }

        dropNodes.sort((a, b) => a.x - b.x);
        for (let i = 0; i < dropNodes.length - 1; i++) {
          const left = dropNodes[i];
          const right = dropNodes[i + 1];
          elements.push({
            data: {
              id: `${left.id}_sib_${right.id}`,
              source: left.id,
              target: right.id,
              familyId: family.id,
              kind: "sibship"
            },
            classes: "sibship-link"
          });
        }

        const anchor = dropNodes[Math.floor(dropNodes.length / 2)];
        if (anchor) {
          elements.push({
            data: {
              id: `${connectorId}_anchor_${anchor.id}`,
              source: connectorId,
              target: anchor.id,
              familyId: family.id,
              kind: "sibship_anchor"
            },
            classes: "sibship-link"
          });
        }
      }

      const handledKinds = new Set(["parent_of", "child_of", "spouse_of", "partner_of", "divorced_from", "separated_from"]);
      for (const edge of edgeList || []) {
        if (!edge?.data?.source || !edge?.data?.target) continue;
        if (!edge.data.kind || handledKinds.has(edge.data.kind)) continue;
        if (!personMap.has(edge.data.source) || !personMap.has(edge.data.target)) continue;
        elements.push({
          data: { ...edge.data },
          classes: "generic"
        });
      }

      return elements;
    }

    function describePerson(person) {
      if (!person) return null;
      if (person.dob) return `${person.name} (b. ${person.dob})`;
      return person.name || null;
    }

    function formatIssue(issue) {
      if (!issue || typeof issue !== "object") return null;
      if (issue.message) return issue.message;
      switch (issue.type) {
        case "duplicate_person": {
          const names = (issue.people || []).map(describePerson).filter(Boolean);
          if (!names.length) return null;
          return `Possible duplicate records: ${names.join(", ")}`;
        }
        case "parent_age_anomaly": {
          const parent = describePerson(issue.parent);
          const child = describePerson(issue.child);
          if (!parent || !child) return null;
          return `Check ages: ${parent} appears younger than ${child}.`;
        }
        default:
@@ -549,77 +914,64 @@

    async function loadTree() {
      statusEl.textContent = "Loading…";

      try {
        const response = await fetch(`/api/tree?code=${code}`, { cache: "no-store" });
        let payload = null;
        try {
          payload = await response.json();
        } catch (parseError) {
          console.error("Failed to parse tree response", parseError);
        }

        if (!response.ok || !payload) {
          const message = payload?.error || response.statusText || "Unknown error";
          statusEl.textContent = `Error: ${message}`;
          emptyEl.style.display = "flex";
          updateIssuesPanel([]);
          disableSharing();
          return;
        }

        treeNameEl.textContent = payload.tree?.name || "Family Tree";
        document.title = payload.tree?.name ? `Family Tree: ${payload.tree.name}` : "Family Tree";

        const elements = buildElements(
          payload.nodes || [],
          payload.edges || [],
          payload.families || []
        );
        cy.batch(() => {
          cy.elements().remove();
          cy.add(elements);
        });

        const personNodes = cy.nodes(".person");
        const personCount = personNodes.length;
        if (personCount) {
          cy.fit(personNodes, 120);
        } else {
          cy.reset();
        }
        cy.resize();
        emptyEl.style.display = personCount ? "none" : "flex";

        const issueMessages = (payload.issues || []).map(formatIssue).filter(Boolean);
        updateIssuesPanel(issueMessages);

        const stamp = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
        if (issueMessages.length) {
          statusEl.textContent = `Warnings · ${issueMessages.length} issue${issueMessages.length === 1 ? "" : "s"}`;
        } else if (personCount) {
          statusEl.textContent = `Updated ${stamp}`;
        } else {
          statusEl.textContent = `Tree is empty · Updated ${stamp}`;
        }

        enableSharing(payload.tree?.name || "this tree");
      } catch (error) {
        console.error("Failed to load tree", error);
        statusEl.textContent = "Error loading tree";
        emptyEl.style.display = "flex";
        updateIssuesPanel([]);
        disableSharing();
      }
    }

    loadTree();
    setInterval(loadTree, REFRESH_INTERVAL_MS);
  </script>
</body>
</html>
