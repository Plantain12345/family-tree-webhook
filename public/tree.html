<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Family Tree</title>
  <style>
    :root {
      --bg: #ffffff;
      --surface: #ffffff;
      --panel: #fbf7f2;
      --ink: #2f2217;
      --muted: #6f6255;
      --border: #e8ded2;
      --accent: #d87b5d;
      --status-bg: rgba(216, 123, 93, 0.12);
    }

    html,
    body {
      margin: 0;
      min-height: 100%;
      font-family: "Inter", "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--ink);
      background: var(--bg);
    }

    body {
      display: flex;
      flex-direction: column;
    }

    .shell {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 24px;
      padding: 28px 36px 20px;
      background: var(--surface);
      box-shadow: 0 12px 32px rgba(21, 12, 4, 0.05);
      z-index: 10;
    }

    .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .title-prefix {
      text-transform: uppercase;
      letter-spacing: 0.18em;
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
    }

    h1 {
      margin: 0;
      font-size: 26px;
      font-weight: 600;
    }

    .code-block {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 10px 16px;
      border-radius: 14px;
      background: var(--panel);
      box-shadow: 0 8px 22px rgba(22, 13, 4, 0.08);
      border: 1px solid var(--border);
      min-width: 140px;
    }

    .code-prefix {
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 0.16em;
      color: var(--muted);
    }

    .code-value {
      font-size: 18px;
      font-weight: 600;
      letter-spacing: 0.08em;
    }

    #status {
      font-size: 12px;
      font-weight: 500;
      color: var(--accent);
      background: var(--status-bg);
      padding: 8px 14px;
      border-radius: 999px;
      align-self: flex-start;
      white-space: nowrap;
    }

    main {
      flex: 1;
      position: relative;
      padding: 24px 36px 36px;
      background: linear-gradient(180deg, rgba(248, 242, 236, 0.55) 0%, rgba(255, 255, 255, 0.9) 60%, rgba(255, 255, 255, 1) 100%);
      display: flex;
      flex-direction: column;
    }

    .legend {
      position: absolute;
      top: 42px;
      right: 56px;
      display: flex;
      gap: 16px;
      align-items: center;
      padding: 10px 16px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.92);
      box-shadow: 0 10px 28px rgba(19, 11, 4, 0.1);
      border: 1px solid var(--border);
      font-size: 12px;
      color: var(--muted);
      backdrop-filter: blur(6px);
      z-index: 5;
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
      color: var(--ink);
    }

    .legend-swatch {
      width: 16px;
      height: 16px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.55);
      display: inline-block;
      border-radius: 12px;
    }

    .legend-swatch.male {
      background: #c8daf9;
      border-radius: 3px;
    }

    .legend-swatch.female {
      background: #f8d5e4;
      border-radius: 50%;
    }

    .legend-swatch.neutral {
      background: #e3dbf7;
      border-radius: 18%;
    }

    .legend-swatch.unknown {
      background: #f4efe7;
    }

    @media (max-width: 720px) {
      header {
        flex-direction: column;
        align-items: flex-start;
        gap: 18px;
      }

      .code-block {
        flex-direction: row;
        align-items: baseline;
        gap: 12px;
      }

      .legend {
        position: static;
        margin-bottom: 16px;
        flex-wrap: wrap;
        justify-content: center;
      }

      #empty {
        inset: 24px;
      }
    }

    #cy {
      width: 100%;
      flex: 1;
      min-height: 480px;
      border-radius: 26px;
      background: var(--panel);
      border: 1px solid var(--border);
      box-shadow: 0 28px 60px rgba(27, 17, 8, 0.08);
    }

    #empty {
      position: absolute;
      inset: 24px 36px 36px;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    #empty .box {
      text-align: center;
      color: var(--muted);
      padding: 32px 40px;
      border-radius: 20px;
      background: rgba(255, 255, 255, 0.65);
      box-shadow: 0 18px 44px rgba(17, 10, 4, 0.08);
      border: 1px solid var(--border);
    }

    #empty .box strong {
      display: block;
      font-size: 18px;
      margin-bottom: 6px;
      color: var(--ink);
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="title-block">
        <span class="title-prefix">Family Tree:</span>
        <h1 id="tree-name">Loading…</h1>
      </div>
      <div class="code-block">
        <span class="code-prefix">Code No.</span>
        <span class="code-value" id="tree-code">———</span>
      </div>
      <div id="status">Loading…</div>
    </header>

    <main>
      <div class="legend">
        <span class="legend-item"><span class="legend-swatch male"></span>Male</span>
        <span class="legend-item"><span class="legend-swatch female"></span>Female</span>
        <span class="legend-item"><span class="legend-swatch neutral"></span>Non-binary</span>
        <span class="legend-item"><span class="legend-swatch unknown"></span>Not specified</span>
      </div>
      <div id="cy"></div>
      <div id="empty"><div class="box">
        <strong>Invite your family</strong>
        <div>Use WhatsApp to add relatives—try “Add Alice born 1950” or “Link Alice married to Bob”.</div>
      </div></div>
    </main>
  </div>

  <script src="https://unpkg.com/cytoscape@3.27.0/dist/cytoscape.min.js"></script>
  <script>
    const qs = new URLSearchParams(location.search);
    const code = (qs.get("code") || "").toUpperCase();
    const treeNameEl = document.getElementById("tree-name");
    const treeCodeEl = document.getElementById("tree-code");
    const statusEl = document.getElementById("status");
    const emptyEl = document.getElementById("empty");

    if (!/^[A-Z0-9]{6}$/.test(code)) {
      document.body.innerHTML = "<p style='padding:16px'>Missing or bad code. Use ?code=ABC123</p>";
      throw new Error("bad code");
    }

    treeCodeEl.textContent = code;

    const LEVEL_HEIGHT = 200;
    const SPOUSE_GAP = 220;
    const UNIT_GAP = 280;
    const CHILD_GAP = 150;
    const DROP_GAP = 90;
    const DROP_SEGMENT = DROP_GAP / 2;
    const DIVORCE_OFFSET = 32;

    const cy = cytoscape({
      container: document.getElementById('cy'),
      elements: [],
      style: [
        {
          selector: 'node[type = "person"]',
          style: {
            'shape': 'data(shape)',
            'width': 'data(width)',
            'height': 'data(height)',
            'background-color': 'data(color)',
            'border-color': '#d8cec2',
            'border-width': 2,
            'label': 'data(label)',
            'text-wrap': 'wrap',
            'text-max-width': 112,
            'padding': '14px',
            'font-size': 13,
            'font-weight': 500,
            'text-valign': 'center',
            'text-halign': 'center',
            'color': '#322417',
            'line-height': 1.35,
            'shadow-blur': 18,
            'shadow-color': 'rgba(31, 20, 12, 0.18)',
            'shadow-offset-x': 0,
            'shadow-offset-y': 10,
            'shadow-opacity': 1
          }
        },
        {
          selector: 'node.connector',
          style: {
            'width': 2,
            'height': 2,
            'opacity': 0,
            'border-width': 0,
            'background-opacity': 0,
            'events': 'no'
          }
        },
        {
          selector: 'edge',
          style: {
            'width': 2,
            'line-color': '#4a3c31',
            'target-arrow-shape': 'none',
            'source-arrow-shape': 'none',
            'curve-style': 'straight',
            'opacity': 1,
            'line-cap': 'round'
          }
        },
        {
          selector: 'edge[kind = "marriage"]',
          style: { 'width': 3.2, 'line-color': '#2d2117' }
        },
        {
          selector: 'edge[kind = "descent"]',
          style: { 'line-color': '#2d2117' }
        },
        {
          selector: 'edge[kind = "sibling"]',
          style: { 'line-color': '#2d2117' }
        },
        {
          selector: 'edge[kind = "child"]',
          style: { 'line-color': '#2d2117' }
        },
        {
          selector: 'edge[kind = "divorce"]',
          style: {
            'line-color': '#c45b4d',
            'width': 2.2,
            'z-index-compare': 'manual',
            'z-index': 10
          }
        }
      ],
      layout: { name: 'preset' },
      wheelSensitivity: 0.1
    });

    function buildPedigreeLayout(apiNodes, apiEdges, apiFamilies) {
      const nodeMap = new Map(apiNodes.map((n) => [n.data.id, n]));
      const families = (apiFamilies || [])
        .map((f) => ({
          id: f.id,
          spouses: Array.isArray(f.spouses) ? f.spouses.filter((id) => nodeMap.has(id)) : [],
          children: dedupeOrdered(Array.isArray(f.children) ? f.children.filter((id) => nodeMap.has(id)) : []),
          status: f.status || null,
        }))
        .filter((f) => f.spouses.length || f.children.length);

      const { generation } = computeGenerations(apiNodes, apiEdges, families);
      const { positions } = computePositions(apiNodes, families, generation);
      const connectors = buildConnectorElements(families, positions);

      const personElements = apiNodes.map((n) => {
        const glyph = glyphForGender(n.data.gender);
        return {
          data: {
            ...n.data,
            type: 'person',
            color: glyph.color,
            shape: glyph.shape,
            width: glyph.width,
            height: glyph.height,
          },
          position: positions.get(n.data.id) || { x: 0, y: 0 },
          locked: true,
          grabbable: false,
        };
      });

      return {
        personElements,
        connectorNodes: connectors.nodes,
        connectorEdges: connectors.edges,
      };
    }

    function dedupeOrdered(list) {
      const seen = new Set();
      const out = [];
      for (const item of list) {
        if (!seen.has(item)) {
          seen.add(item);
          out.push(item);
        }
      }
      return out;
    }

    function computeGenerations(nodes, edges, families) {
      const ids = new Set(nodes.map((n) => n.data.id));
      const parentsByChild = new Map();
      const childrenByParent = new Map();

      const addRelation = (parent, child) => {
        if (!ids.has(parent) || !ids.has(child)) return;
        if (!parentsByChild.has(child)) parentsByChild.set(child, new Set());
        parentsByChild.get(child).add(parent);
        if (!childrenByParent.has(parent)) childrenByParent.set(parent, new Set());
        childrenByParent.get(parent).add(child);
      };

      for (const edge of edges || []) {
        const kind = edge.data?.kind;
        if (kind === 'parent_of') addRelation(edge.data.source, edge.data.target);
        else if (kind === 'child_of') addRelation(edge.data.target, edge.data.source);
      }

      const generation = new Map();
      const indegree = new Map();

      nodes.forEach((n) => {
        const id = n.data.id;
        const indeg = parentsByChild.get(id)?.size || 0;
        indegree.set(id, indeg);
        if (indeg === 0) generation.set(id, 0);
      });

      const queue = nodes.filter((n) => (indegree.get(n.data.id) || 0) === 0).map((n) => n.data.id);
      const seen = new Set(queue);

      while (queue.length) {
        const current = queue.shift();
        const gen = generation.get(current) ?? 0;
        const children = childrenByParent.get(current);
        if (!children) continue;
        children.forEach((child) => {
          const nextGen = gen + 1;
          const prevGen = generation.get(child);
          if (prevGen === undefined || nextGen > prevGen) generation.set(child, nextGen);
          const newIn = (indegree.get(child) || 0) - 1;
          indegree.set(child, newIn);
          if (newIn <= 0 && !seen.has(child)) {
            queue.push(child);
            seen.add(child);
          }
        });
      }

      nodes.forEach((n) => {
        if (!generation.has(n.data.id)) generation.set(n.data.id, 0);
      });

      families.forEach((f) => {
        const spouseGens = f.spouses.map((id) => generation.get(id)).filter((g) => g !== undefined);
        if (!spouseGens.length) return;
        const level = Math.min(...spouseGens);
        f.spouses.forEach((id) => generation.set(id, level));
      });

      return { generation };
    }

    function computePositions(nodes, families, generation) {
      const labelById = new Map(nodes.map((n) => [n.data.id, n.data.label || '']));
      const levels = Array.from(new Set(Array.from(generation.values()))).sort((a, b) => a - b);
      const positions = new Map();
      const positionHints = new Map();
      const orderHints = new Map();

      levels.forEach((level) => {
        const y = level * LEVEL_HEIGHT;
        const idsAtLevel = nodes.filter((n) => generation.get(n.data.id) === level).map((n) => n.data.id);
        const placed = new Set();

        const familiesAtLevel = families.filter((f) => f.spouses.length && f.spouses.every((id) => generation.get(id) === level));
        const familyEntries = familiesAtLevel.map((f) => {
          const hints = f.spouses.map((id) => positionHints.get(id)).filter((v) => v !== undefined);
          const centerHint = hints.length ? hints.reduce((sum, v) => sum + v, 0) / hints.length : undefined;
          const orderHint = Math.min(...f.spouses.map((id) => orderHints.get(id) ?? Infinity));
          return { family: f, centerHint, orderHint };
        });

        familyEntries.sort((a, b) => {
          const aHasCenter = a.centerHint !== undefined;
          const bHasCenter = b.centerHint !== undefined;
          if (aHasCenter && bHasCenter && a.centerHint !== b.centerHint) return a.centerHint - b.centerHint;
          if (aHasCenter !== bHasCenter) return aHasCenter ? -1 : 1;
          const orderA = a.orderHint ?? Infinity;
          const orderB = b.orderHint ?? Infinity;
          if (orderA !== orderB) return orderA - orderB;
          const labelA = (a.family.spouses.map((id) => labelById.get(id) || '').sort()[0]) || '';
          const labelB = (b.family.spouses.map((id) => labelById.get(id) || '').sort()[0]) || '';
          return labelA.localeCompare(labelB);
        });

        let xCursor = 0;
        let familyIndex = 0;

        familyEntries.forEach(({ family, centerHint }) => {
          const spouseIds = family.spouses.filter((id) => generation.get(id) === level);
          if (!spouseIds.length) return;

          const span = (spouseIds.length - 1) * SPOUSE_GAP;
          let centerX = centerHint;
          if (centerX === undefined) centerX = xCursor + span / 2;
          if (centerX < xCursor + span / 2) centerX = xCursor + span / 2;
          const startX = centerX - span / 2;

          spouseIds.forEach((id, idx) => {
            const x = startX + idx * SPOUSE_GAP;
            positions.set(id, { x, y });
            positionHints.set(id, x);
            orderHints.set(id, familyIndex + idx * 0.01);
            placed.add(id);
          });

          const center = centerX;
          const uniqueChildren = family.children || [];
          if (uniqueChildren.length) {
            const base = -((uniqueChildren.length - 1) / 2) * CHILD_GAP;
            uniqueChildren.forEach((childId, idx) => {
              const hintX = center + base + idx * CHILD_GAP;
              const existing = positionHints.get(childId);
              positionHints.set(childId, existing === undefined ? hintX : (existing + hintX) / 2);
              orderHints.set(childId, familyIndex + idx / Math.max(uniqueChildren.length, 1));
            });
          }

          xCursor = Math.max(xCursor, center + span / 2) + UNIT_GAP;
          familyIndex += 1;
        });

        const singles = idsAtLevel.filter((id) => !placed.has(id));
        singles.sort((a, b) => {
          const orderA = orderHints.get(a) ?? Infinity;
          const orderB = orderHints.get(b) ?? Infinity;
          if (orderA !== orderB) return orderA - orderB;
          const labelA = labelById.get(a) || '';
          const labelB = labelById.get(b) || '';
          return labelA.localeCompare(labelB);
        });

        singles.forEach((id, idx) => {
          let x = positionHints.get(id);
          if (x === undefined || x < xCursor) x = xCursor;
          positions.set(id, { x, y });
          positionHints.set(id, x);
          orderHints.set(id, (orderHints.get(id) ?? familyIndex) + idx * 0.01);
          xCursor = x + UNIT_GAP;
        });

        families
          .filter((f) => f.spouses.length === 1 && generation.get(f.spouses[0]) === level)
          .forEach((family) => {
            const parentId = family.spouses[0];
            const parentPos = positions.get(parentId);
            if (!parentPos) return;
            const uniqueChildren = family.children || [];
            if (!uniqueChildren.length) return;
            const base = -((uniqueChildren.length - 1) / 2) * CHILD_GAP;
            uniqueChildren.forEach((childId, idx) => {
              const hintX = parentPos.x + base + idx * CHILD_GAP;
              const existing = positionHints.get(childId);
              positionHints.set(childId, existing === undefined ? hintX : (existing + hintX) / 2);
            });
          });
      });

      nodes.forEach((n) => {
        const id = n.data.id;
        if (!positions.has(id)) {
          const gen = generation.get(id) || 0;
          const y = gen * LEVEL_HEIGHT;
          const x = positionHints.get(id) ?? 0;
          positions.set(id, { x, y });
        }
      });

      return { positions };
    }

    function buildConnectorElements(families, positions) {
      const nodes = [];
      const edges = [];

      families.forEach((family) => {
        const spousePositions = family.spouses.map((id) => positions.get(id)).filter(Boolean);
        if (!spousePositions.length) return;
        const centerX = spousePositions.reduce((sum, pos) => sum + pos.x, 0) / spousePositions.length;
        const parentY = spousePositions.reduce((sum, pos) => sum + pos.y, 0) / spousePositions.length;
        const marriageId = `family:${family.id}:marriage`;

        nodes.push({
          data: { id: marriageId, type: 'connector', role: 'marriage', familyId: family.id },
          position: { x: centerX, y: parentY },
          selectable: false,
          grabbable: false,
          locked: true,
          classes: 'connector',
        });

        family.spouses
          .filter((id) => positions.has(id))
          .sort((a, b) => positions.get(a).x - positions.get(b).x)
          .forEach((spouseId) => {
            edges.push({
              data: { id: `family:${family.id}:marriage:${spouseId}`, source: marriageId, target: spouseId, kind: 'marriage' },
              selectable: false,
              classes: 'connector-edge',
            });
          });

        if (family.status && family.spouses.length >= 2) {
          const diagAId = `family:${family.id}:divorce-a`;
          const diagBId = `family:${family.id}:divorce-b`;
          nodes.push({
            data: { id: diagAId, type: 'connector', role: 'divorce', familyId: family.id },
            position: { x: centerX - DIVORCE_OFFSET, y: parentY - DIVORCE_OFFSET },
            selectable: false,
            grabbable: false,
            locked: true,
            classes: 'connector',
          });
          nodes.push({
            data: { id: diagBId, type: 'connector', role: 'divorce', familyId: family.id },
            position: { x: centerX + DIVORCE_OFFSET, y: parentY + DIVORCE_OFFSET },
            selectable: false,
            grabbable: false,
            locked: true,
            classes: 'connector',
          });
          edges.push({
            data: {
              id: `family:${family.id}:divorce-line`,
              source: diagAId,
              target: diagBId,
              kind: 'divorce',
              status: family.status,
            },
            selectable: false,
            classes: 'connector-edge',
          });
        }

        const childIds = (family.children || []).filter((id) => positions.has(id));
        if (!childIds.length) return;

        const dropMidId = `family:${family.id}:drop-mid`;
        const bracketId = `family:${family.id}:sibship`;
        const dropMidY = parentY + DROP_SEGMENT;
        const bracketY = parentY + DROP_GAP;

        nodes.push({
          data: { id: dropMidId, type: 'connector', role: 'drop-mid', familyId: family.id },
          position: { x: centerX, y: dropMidY },
          selectable: false,
          grabbable: false,
          locked: true,
          classes: 'connector',
        });

        nodes.push({
          data: { id: bracketId, type: 'connector', role: 'sibship', familyId: family.id },
          position: { x: centerX, y: bracketY },
          selectable: false,
          grabbable: false,
          locked: true,
          classes: 'connector',
        });

        edges.push({
          data: { id: `family:${family.id}:anchor-drop`, source: marriageId, target: dropMidId, kind: 'descent' },
          selectable: false,
          classes: 'connector-edge',
        });

        edges.push({
          data: { id: `family:${family.id}:drop-sib`, source: dropMidId, target: bracketId, kind: 'descent' },
          selectable: false,
          classes: 'connector-edge',
        });

        const jointEntries = childIds.map((childId) => {
          const childPos = positions.get(childId);
          const jointId = `family:${family.id}:child:${childId}:joint`;

          nodes.push({
            data: { id: jointId, type: 'connector', role: 'child-joint', familyId: family.id, personId: childId },
            position: { x: childPos.x, y: bracketY },
            selectable: false,
            grabbable: false,
            locked: true,
            classes: 'connector',
          });

          edges.push({
            data: { id: `family:${family.id}:child-${childId}`, source: jointId, target: childId, kind: 'child' },
            selectable: false,
            classes: 'connector-edge',
          });

          return { jointId, childId, x: childPos.x };
        });

        if (jointEntries.length === 1) {
          edges.push({
            data: { id: `family:${family.id}:sibship-0`, source: bracketId, target: jointEntries[0].jointId, kind: 'sibling' },
            selectable: false,
            classes: 'connector-edge',
          });
        } else if (jointEntries.length > 1) {
          edges.push({
            data: { id: `family:${family.id}:sibship-start`, source: bracketId, target: jointEntries[0].jointId, kind: 'sibling' },
            selectable: false,
            classes: 'connector-edge',
          });

          for (let i = 0; i < jointEntries.length - 1; i++) {
            edges.push({
              data: {
                id: `family:${family.id}:sibship-${i}-${i + 1}`,
                source: jointEntries[i].jointId,
                target: jointEntries[i + 1].jointId,
                kind: 'sibling',
              },
              selectable: false,
              classes: 'connector-edge',
            });
          }
        }
      });

      return { nodes, edges };
    }

    function glyphForGender(gender) {
      switch (gender) {
        case 'male':
          return { color: '#c8daf9', shape: 'square', width: 120, height: 120 };
        case 'female':
          return { color: '#f8d5e4', shape: 'ellipse', width: 120, height: 120 };
        case 'nonbinary':
        case 'non-binary':
        case 'nb':
          return { color: '#e3dbf7', shape: 'round-diamond', width: 130, height: 130 };
        default:
          return { color: '#f4efe7', shape: 'round-rectangle', width: 148, height: 112 };
      }
    }

    async function load() {
      statusEl.textContent = "Loading…";
      try {
        const r = await fetch(`/api/tree?code=${code}`, { cache: 'no-store' });
        const data = await r.json();
        if (!r.ok) {
          statusEl.textContent = `Error: ${data.error || r.status}`;
          emptyEl.style.display = 'flex';
          return;
        }

        treeNameEl.textContent = data.tree.name;
        treeCodeEl.textContent = data.tree.code;
        document.title = `Family Tree: ${data.tree.name}`;

        const layout = buildPedigreeLayout(data.nodes || [], data.edges || [], data.families || []);

        cy.startBatch();
        cy.elements().remove();
        cy.add(layout.personElements);
        if (layout.connectorNodes.length) cy.add(layout.connectorNodes);
        if (layout.connectorEdges.length) cy.add(layout.connectorEdges);
        cy.endBatch();

        const personCount = layout.personElements.length;
        emptyEl.style.display = personCount ? 'none' : 'flex';
        cy.resize();
        if (personCount) {
          const people = cy.collection('node[type = "person"]');
          cy.fit(people, 140);
        }

        const stamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        statusEl.textContent = `Synced · ${stamp}`;
      } catch (e) {
        console.error(e);
        statusEl.textContent = "Error loading";
        emptyEl.style.display = 'flex';
      }
    }

    load();
    setInterval(load, 8000);
  </script>
</body>
</html>
